import pymysql

class MySQLCRUD:
    """
    This class provides CRUD (Create, Read, Update, Delete) services for a MySQL database
    using pymysql.  This class handles connection management, executes queries,
    and returns data in a user-friendly format (dictionaries).  It also
    includes error handling with rollback.
    
    Generated by Google GEMINI
    
    See example usage in docs/aicruddoc.py
    """
    def __init__(self, host, user, password, database, port=3306):
        self.host = host
        self.user = user
        self.password = password
        self.database = database
        self.port = port  # Added port
        self.connection = None
        self.cursor = None

    def _connect(self):
        try:
            self.connection = pymysql.connect(
                host=self.host,
                user=self.user,
                password=self.password,
                database=self.database,
                port=self.port,  # Use the port
                cursorclass=pymysql.cursors.DictCursor  # Fetch results as dictionaries
            )
            self.cursor = self.connection.cursor()
        except Exception as e:
            raise Exception(f"Error connecting to MySQL: {e}")

    def _disconnect(self):
         if self.connection:
            try:
                self.connection.close()
            except Exception as e:
                print(f"Error closing MySQL connection: {e}")  # Log the error
            finally:
                self.connection = None
                self.cursor = None

    def create(self, table, data):
        try:
            self._connect()
            columns = ', '.join(data.keys())
            placeholders = ', '.join(['%s'] * len(data))
            query = f"INSERT INTO {table} ({columns}) VALUES ({placeholders})"
            values = list(data.values())
            self.cursor.execute(query, values)
            self.connection.commit()
            return self.cursor.lastrowid
        except Exception as e:
            if self.connection:
                self.connection.rollback()
            raise Exception(f"Error creating record in {table}: {e}")
        finally:
            self._disconnect()

    def read_one(self, table, condition, values=None):
        try:
            self._connect()
            query = f"SELECT * FROM {table} WHERE {condition} LIMIT 1"
            self.cursor.execute(query, values) if values else self.cursor.execute(query)
            return self.cursor.fetchone()  # Fetch a single record as a dictionary
        except Exception as e:
            raise Exception(f"Error reading record from {table}: {e}")
            return False
        finally:
            self._disconnect()

    def read_all(self, table, condition=None, values=None, order_by=None, limit=None, offset=None):
        try:
            self._connect()
            query = f"SELECT * FROM {table}"
            if condition:
                query += f" WHERE {condition}"
            if order_by:
                query += f" ORDER BY {order_by}"
            if limit is not None:
                query += f" LIMIT {limit}"
                if offset is not None:
                    query += f" OFFSET {offset}"

            self.cursor.execute(query, values) if values else self.cursor.execute(query)
            return self.cursor.fetchall()
        except Exception as e:
            raise Exception(f"Error reading records from {table}: {e}")
        finally:
            self._disconnect()

    def update(self, table, data, condition, values=None):
        try:
            self._connect()
            set_clause = ', '.join([f"{key} = %s" for key in data])
            query = f"UPDATE {table} SET {set_clause} WHERE {condition}"
            all_values = list(data.values()) + (list(values) if values else [])
            self.cursor.execute(query, all_values)
            self.connection.commit()
            return self.cursor.rowcount
        except Exception as e:
            if self.connection:
                self.connection.rollback()
            raise Exception(f"Error updating records in {table}: {e}")
        finally:
            self._disconnect()

    def delete(self, table, condition=None, values=None):
        try:
            self._connect()
            query = f"DELETE FROM {table} WHERE {condition}"
            print(f'Delete Query: {query}')
            self.cursor.execute(query, values) if values else self.cursor.execute(query)
            self.connection.commit()
            return self.cursor.rowcount
        except Exception as e:
            if self.connection:
                self.connection.rollback()
            print(f'aircrud exception error: {e}', flush=True)
            raise Exception(f"Error deleting records from {table}: {e}")
        finally:
            self._disconnect()

    def execute_query(self, query, values=None, fetch=False):
        try:
            self._connect()
            self.cursor.execute(query, values) if values else self.cursor.execute(query)
            self.connection.commit()
            if fetch:
                return self.cursor.fetchall()
            else:
                return self.cursor.rowcount
        except Exception as e:
            if self.connection:
                self.connection.rollback()
            raise Exception(f"Error executing query: {e}")
        finally:
            self._disconnect()
